{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome AliceOS is a robust and evolving framework for developing interactive visual novel experiences with operating system-like features such as notifications and setup assistants. Features and Principles The core principles of AliceOS are: Modular : AliceOS uses a new framework format, under the .aosframework format. These frameworks are placed in the System/Frameworks folder and are not heavily reliant on AppKit.aosframework. However, the definitions file that states the default directories and what-not must be included in the System folder (including fonts). Apple-style APIs : AliceOS's APIs aim to be easy-to-use and familiar to developers that have worked with APIs for macOS, iOS, tvOS, and watchOS. Safely extensible : AliceOS includes support for extending itself with apps that are protected using appropriate, official APIs. Easy-to-install : AliceOS installation is as easy as just copying the Ren'Py archive over to the game folder.","title":"Welcome"},{"location":"#welcome","text":"AliceOS is a robust and evolving framework for developing interactive visual novel experiences with operating system-like features such as notifications and setup assistants.","title":"Welcome"},{"location":"#features-and-principles","text":"The core principles of AliceOS are: Modular : AliceOS uses a new framework format, under the .aosframework format. These frameworks are placed in the System/Frameworks folder and are not heavily reliant on AppKit.aosframework. However, the definitions file that states the default directories and what-not must be included in the System folder (including fonts). Apple-style APIs : AliceOS's APIs aim to be easy-to-use and familiar to developers that have worked with APIs for macOS, iOS, tvOS, and watchOS. Safely extensible : AliceOS includes support for extending itself with apps that are protected using appropriate, official APIs. Easy-to-install : AliceOS installation is as easy as just copying the Ren'Py archive over to the game folder.","title":"Features and Principles"},{"location":"01-install/","text":"Getting Started This document will help you get started with installing AliceOS and attaching it to your Ren'Py project. Downloading the base system If you do not plan to customize AliceOS too much, you can add the base system archive and use AliceOS that way. Download the latest release from the Downloads page and extract the ZIP archive. Then, copy AliceOSBaseSystem.rpa over to your Ren'Py project's game folder. Ensure compatibility The latest version of AliceOS for download will always correspond to the latest version of the Ren'Py SDK made available at that time. At the time of writing, this means that AliceOS is building against Ren'Py SDK v 7.3.2 . If you are unsure of what version AliceOS is built with, check the Travis results and click on \"Ren'Py Latest SDK\". It is recommend that you make sure that your version of Ren'Py is up to date to ensure compatibility with AliceOS. Usage with DDLC Mods If you plan to use AliceOS in a mod for Doki Doki Literature Club! , you must make sure that the base system version that you use is built against Ren'Py 6.99.12.4 to maintain compatibility. The release ZIP file is generally noted as 'AliceOS-x.x.x-_AliceOSBaseSystem-rp6.zip'. Building from source code Alternatively, you can build AliceOSBaseSystem.rpa yourself with the customization you need. This may also be helpful in building AliceOS for your specific Ren'Py version, if necessary. Download the source code for the particular release you'd like and open Ren'Py Launcher. Select the AliceOS source code and click \"Build Distributions\". Uncheck the distribution options and check \"Alice OS Base System Distributable\". Click \"Build\". Your resulting ZIP file will be located in AliceOS-x.x.x-dists , and you can follow the instructions from Downloading the base system to finalize installation.","title":"Getting Started"},{"location":"01-install/#getting-started","text":"This document will help you get started with installing AliceOS and attaching it to your Ren'Py project.","title":"Getting Started"},{"location":"01-install/#downloading-the-base-system","text":"If you do not plan to customize AliceOS too much, you can add the base system archive and use AliceOS that way. Download the latest release from the Downloads page and extract the ZIP archive. Then, copy AliceOSBaseSystem.rpa over to your Ren'Py project's game folder. Ensure compatibility The latest version of AliceOS for download will always correspond to the latest version of the Ren'Py SDK made available at that time. At the time of writing, this means that AliceOS is building against Ren'Py SDK v 7.3.2 . If you are unsure of what version AliceOS is built with, check the Travis results and click on \"Ren'Py Latest SDK\". It is recommend that you make sure that your version of Ren'Py is up to date to ensure compatibility with AliceOS.","title":"Downloading the base system"},{"location":"01-install/#usage-with-ddlc-mods","text":"If you plan to use AliceOS in a mod for Doki Doki Literature Club! , you must make sure that the base system version that you use is built against Ren'Py 6.99.12.4 to maintain compatibility. The release ZIP file is generally noted as 'AliceOS-x.x.x-_AliceOSBaseSystem-rp6.zip'.","title":"Usage with DDLC Mods"},{"location":"01-install/#building-from-source-code","text":"Alternatively, you can build AliceOSBaseSystem.rpa yourself with the customization you need. This may also be helpful in building AliceOS for your specific Ren'Py version, if necessary. Download the source code for the particular release you'd like and open Ren'Py Launcher. Select the AliceOS source code and click \"Build Distributions\". Uncheck the distribution options and check \"Alice OS Base System Distributable\". Click \"Build\". Your resulting ZIP file will be located in AliceOS-x.x.x-dists , and you can follow the instructions from Downloading the base system to finalize installation.","title":"Building from source code"},{"location":"02-contributing/","text":"Contribution Guidelines AliceOS is free and open-source software, hosted on GitHub, and accepts contributions from the community. To make the contribution process quick, smooth, easy, and fun, we've devised a set of guidelines to ensure code quality and security. Please consult these when making a pull request, issue, etc. General Code Guidelines These guidelines apply to code that is written in AliceOS. Follow the AliceOS API Styling Although AliceOS is a Python-based framework, our APIs are similarly written to those of the APIs used when creating macOS and iOS apps and are in camel case. This usually serves two purposes: To identify AliceOS code from the rest of a visual novel project To make it easy to understand when migrating from Apple platform development Example: applicationWillRequestNotification vs. application_will_request_notification System-wide variables such as release names should be capitalized and use snake case as normal. Example: AS_SYS_VERSION vs. asSysVersion Follow commit conventions The AliceOS team has adopted the same commit conventions from Clarity , the parent organization running Sayonika. This commit style definitely explains where changes occured and what was changed in a succinct manner. However, there are some changes we have made to this commit style: Common directories such as System, Applications, and Library do not need to be fully typed out. File extensions for frameworks ( .aosframework ), core services ( .aoscservice ), and applications ( .aosapp ) do not need to be typed out. Example: [S/F/ServiceKit] Resolve misnaming of serviceWillRequestNotification from applicationWillRequestNotification Keep code organized The AliceOS structure is organized based on a simple macOS file structure to make everything easy to locate. Please try to keep this organization when contributing your code. Issues These guidelines apply to issues on GitHub. Be as descriptive and concise as possible So that AliceOS contributors and developers can better understand what the issue or request may be, issue descriptions should be concise but also descrptive. Refrain from writing an issue in a convoluted way that confuses others. Additionally, if you feel using a screenshot or video will better illustrate your description, add them in conjuction with (or to replace) the description. Remember to consult the Screenshot Guidelines . Label your issue during creation Issues are categorized by types such as bug , enhancement , question , etc. by contributors that can access labels. Since it isn't possible to tag an issue during creation, prepend the tag to your issue's title. Example: [Bug] applicationShouldRequestNotification always returns False Pull Requests These guides apply to pull requests on GitHub. Describe all of your changes Pull requests generally include many changes that address a particular problem or a set of problems. Explain all of the changes you made; you may also specify the subsystems (directories) by using the commit message style. Example: This PR makes the following changes: [S/F/ServiceKit] Renames applicationWillRequestSync to serviceWillRequestSync [S/A/Messages] Adds new MessagesView to view conversation history Reference existing issues and PRs If applicable, pull requests will reference the issues they are fixing in the description. This helps organize contributions in a few ways: Automates closing issues when they are fixed Verifies that the pull request fixes the issue(s) in question Makes a reference in the issue's thread for context If there are any documented issues that the pull request addresses, reference them in the description of the pull request. Example: [S/A/Logokas] Resolve applicationShouldRequestLogokasPermission to correct booleans (fixes #1) Screenshots These guidelines apply to screenshots that are used for reference in issues and/or pull requests. Respect the post author's visibility Mastodon supports posting to four different visibility levels. As a means of respecting privacy, please keep in mind the following: Do not post a status published as a direct message, followers-only, or unlisted status unless you have explicit permission from the status author. If you made a direct message to yourself to demo a feature or fix a bug present in a post, you do not need to worry. If you are unsure whether a public status should be included in a screenshot, consult the post author. Ensure screenshots are clear Screenshots are often included to help illustrate or demonstrate a point with an issue or pull request. It may be difficult to understand the screenshot's purpose if the image is too small or distorted. Ensure that all screenshots are clear and visible. For Official Contributors For official developers and Project Alice members, there are some additional guidelines to follow to ensure that code is signed and verified: Sign off your code and enable verified commits Verified commits let developers, contributors, and users know that the code they are working with is from a trusted source. These commits are signed using GPG or S/MIME and are verified on GitHub. It is mandatory that AliceOS developers and Project Alice members set up verified commits on their device(s) and any tools to digitally sign their code when pushing to GitHub. More information can be found on GitHub's support page .","title":"Contribution Guidelines"},{"location":"02-contributing/#contribution-guidelines","text":"AliceOS is free and open-source software, hosted on GitHub, and accepts contributions from the community. To make the contribution process quick, smooth, easy, and fun, we've devised a set of guidelines to ensure code quality and security. Please consult these when making a pull request, issue, etc.","title":"Contribution Guidelines"},{"location":"02-contributing/#general-code-guidelines","text":"These guidelines apply to code that is written in AliceOS.","title":"General Code Guidelines"},{"location":"02-contributing/#follow-the-aliceos-api-styling","text":"Although AliceOS is a Python-based framework, our APIs are similarly written to those of the APIs used when creating macOS and iOS apps and are in camel case. This usually serves two purposes: To identify AliceOS code from the rest of a visual novel project To make it easy to understand when migrating from Apple platform development Example: applicationWillRequestNotification vs. application_will_request_notification System-wide variables such as release names should be capitalized and use snake case as normal. Example: AS_SYS_VERSION vs. asSysVersion","title":"Follow the AliceOS API Styling"},{"location":"02-contributing/#follow-commit-conventions","text":"The AliceOS team has adopted the same commit conventions from Clarity , the parent organization running Sayonika. This commit style definitely explains where changes occured and what was changed in a succinct manner. However, there are some changes we have made to this commit style: Common directories such as System, Applications, and Library do not need to be fully typed out. File extensions for frameworks ( .aosframework ), core services ( .aoscservice ), and applications ( .aosapp ) do not need to be typed out. Example: [S/F/ServiceKit] Resolve misnaming of serviceWillRequestNotification from applicationWillRequestNotification","title":"Follow commit conventions"},{"location":"02-contributing/#keep-code-organized","text":"The AliceOS structure is organized based on a simple macOS file structure to make everything easy to locate. Please try to keep this organization when contributing your code.","title":"Keep code organized"},{"location":"02-contributing/#issues","text":"These guidelines apply to issues on GitHub.","title":"Issues"},{"location":"02-contributing/#be-as-descriptive-and-concise-as-possible","text":"So that AliceOS contributors and developers can better understand what the issue or request may be, issue descriptions should be concise but also descrptive. Refrain from writing an issue in a convoluted way that confuses others. Additionally, if you feel using a screenshot or video will better illustrate your description, add them in conjuction with (or to replace) the description. Remember to consult the Screenshot Guidelines .","title":"Be as descriptive and concise as possible"},{"location":"02-contributing/#label-your-issue-during-creation","text":"Issues are categorized by types such as bug , enhancement , question , etc. by contributors that can access labels. Since it isn't possible to tag an issue during creation, prepend the tag to your issue's title. Example: [Bug] applicationShouldRequestNotification always returns False","title":"Label your issue during creation"},{"location":"02-contributing/#pull-requests","text":"These guides apply to pull requests on GitHub.","title":"Pull Requests"},{"location":"02-contributing/#describe-all-of-your-changes","text":"Pull requests generally include many changes that address a particular problem or a set of problems. Explain all of the changes you made; you may also specify the subsystems (directories) by using the commit message style. Example: This PR makes the following changes: [S/F/ServiceKit] Renames applicationWillRequestSync to serviceWillRequestSync [S/A/Messages] Adds new MessagesView to view conversation history","title":"Describe all of your changes"},{"location":"02-contributing/#reference-existing-issues-and-prs","text":"If applicable, pull requests will reference the issues they are fixing in the description. This helps organize contributions in a few ways: Automates closing issues when they are fixed Verifies that the pull request fixes the issue(s) in question Makes a reference in the issue's thread for context If there are any documented issues that the pull request addresses, reference them in the description of the pull request. Example: [S/A/Logokas] Resolve applicationShouldRequestLogokasPermission to correct booleans (fixes #1)","title":"Reference existing issues and PRs"},{"location":"02-contributing/#screenshots","text":"These guidelines apply to screenshots that are used for reference in issues and/or pull requests.","title":"Screenshots"},{"location":"02-contributing/#respect-the-post-authors-visibility","text":"Mastodon supports posting to four different visibility levels. As a means of respecting privacy, please keep in mind the following: Do not post a status published as a direct message, followers-only, or unlisted status unless you have explicit permission from the status author. If you made a direct message to yourself to demo a feature or fix a bug present in a post, you do not need to worry. If you are unsure whether a public status should be included in a screenshot, consult the post author.","title":"Respect the post author's visibility"},{"location":"02-contributing/#ensure-screenshots-are-clear","text":"Screenshots are often included to help illustrate or demonstrate a point with an issue or pull request. It may be difficult to understand the screenshot's purpose if the image is too small or distorted. Ensure that all screenshots are clear and visible.","title":"Ensure screenshots are clear"},{"location":"02-contributing/#for-official-contributors","text":"For official developers and Project Alice members, there are some additional guidelines to follow to ensure that code is signed and verified:","title":"For Official Contributors"},{"location":"02-contributing/#sign-off-your-code-and-enable-verified-commits","text":"Verified commits let developers, contributors, and users know that the code they are working with is from a trusted source. These commits are signed using GPG or S/MIME and are verified on GitHub. It is mandatory that AliceOS developers and Project Alice members set up verified commits on their device(s) and any tools to digitally sign their code when pushing to GitHub. More information can be found on GitHub's support page .","title":"Sign off your code and enable verified commits"},{"location":"Develop-Apps/","text":"Develop Apps - Overview Apps are a fun and extensible means of further enhancing the AliceOS environment without needing to customize the base installation and recompile from source. Apps also take advantage of AliceOS's features and frameworks, such as NotificationKit and ScreenKit. To accomplish this, apps use AppKit, the official API set for writing custom apps for the AliceOS framework. About this section The following documentation will cover the important facets of creating an AliceOS app and what frameworks are available. It will also cover important guidelines that all AliceOS apps should follow to maintain security, privacy, and consistency. Warning AliceOS's AppKit should not be confused with Apple's AppKit for macOS, the interface kit responsible for creating macOS applications.","title":"Develop Apps - Overview"},{"location":"Develop-Apps/#develop-apps-overview","text":"Apps are a fun and extensible means of further enhancing the AliceOS environment without needing to customize the base installation and recompile from source. Apps also take advantage of AliceOS's features and frameworks, such as NotificationKit and ScreenKit. To accomplish this, apps use AppKit, the official API set for writing custom apps for the AliceOS framework.","title":"Develop Apps - Overview"},{"location":"Develop-Apps/#about-this-section","text":"The following documentation will cover the important facets of creating an AliceOS app and what frameworks are available. It will also cover important guidelines that all AliceOS apps should follow to maintain security, privacy, and consistency. Warning AliceOS's AppKit should not be confused with Apple's AppKit for macOS, the interface kit responsible for creating macOS applications.","title":"About this section"},{"location":"Develop-Apps/01-manifest/","text":"Declaring Your App Any app for AliceOS has its own manifest and declarations for what the app does. Luckily, defining an app is as easy as writing it directly into the class that all AliceOS apps inherit from. Typical app structure Apps are usually located in Applications , inside of the game folder, and have the file extension .aosapp . Inside of the file, a Ren'Py script help determine details about the app, and a Resources folder is included to add assets such as icons, images, and definitions. For instance, if we are creating an app call Foobanizer , the structure would look like this: game / Applications / Foobanizer . aosapp / Foobanizer . rpy Resources / Iconset / 16 . png 24 . png 32 . png 48 . png 64 . png 128 . png 256 . png Note that the icons are located in Resources/Iconset/ and have sizes for 16px, 24px, 32px, 48px, 64px, 128px, and 256px. These icons are important as they will appear in notifications, the desktop, and other places that require an icon. Writing your app's manifest AliceOS apps' manifests are included directly inside of their main app delegate, a subclass of ASAppRepresentative() . There are several important key field that should be directly written: bundleName : The name of the application. bundleId : The ID of the application in reverse domain name notation . bundleDir : The location of the application. By default, apps use AS_APPS_DIR + \" applicationname .aosapp/\" . bundleAuthor : The author or organization that developed the application. bundleVersion : The version of the application. bundleDescription : The description of the application. Agan, if we wanted to write Foobanizer's manifest, it'd look like this: init 10 python : class Foobanizer ( ASAppRepresentative ): bundleName = Foobanizer bundleId = app.aliceos.foobanizer bundleDir = AS_APPS_DIR + Foobanizer.aosapp/ bundleAuthor = AliceOS Developers bundleVersion = 1.0.0 bundleDescription = \\ Generate random foobanized strings on the fly. ... Declaring permissions Apps that need to make use of notifications via NotificationKit, modify files, watch system events, etc., must declare their permissions. This is done inside of the class via the requires dictionary: requires = { } The main permissions are: AS_REQUIRES_NOTIFICATIONKIT : Requires NotificationKit to send notifications AS_REQUIRES_FULL_DISK_ACCESS : Requires accessing files AS_REQUIRES_SYSTEM_EVENTS : Requires changing settings or watching for events Important All AppKit apps must include this field. If you don't need any permissions or aren't using specific frameworks, leave the dictionary empty. More information on permissions can be found accordingly: Declaring notification permissions Rebuilding icons Icons for AliceOS apps typically reside in the app's Resources folder, though ASAppRepresentative may not pick it up at first. To ensure your app's icon locations are updated, make sure you initialize the class, where applicationname is the name of your app: def __init__ ( self ): ASAppRepresentative . __init__ ( self , AS_DEFAULT_APP_DIR + applicationname .aosapp/ ) Again, if we wanted to rebuild Foobanizer's icons: def __init__ ( self ): ASAppRepresentative . __init__ ( self , AS_APPS_DIR + Foobanizer.aosapp/ ) Example manifest Here's what the manifest file for Foobanizer would look like: # ASAppRepresentative is a Python class. # Everything must be wrapped in a Python block. init 10 python : class Foobanizer ( ASAppRepresentative ): bundleName = Foobanizer bundleId = app.aliceos.foobanizer bundleDir = AS_APPS_DIR + Foobanizer.aosapp/ bundleAuthor = AliceOS Developers bundleVersion = 1.0.0 bundleDescription = \\ Generate random foobanized strings on the fly. # Foobanizer doesn t require any permissions. requires = { } def __init__ ( self ): ASAppRepresentative . __init__ ( self , AS_APPS_DIR + Foobanizer.aosapp/ ) # Finally, we create an instance to pre-load. foobanizer = Foobanizer ()","title":"Declaring Your App"},{"location":"Develop-Apps/01-manifest/#declaring-your-app","text":"Any app for AliceOS has its own manifest and declarations for what the app does. Luckily, defining an app is as easy as writing it directly into the class that all AliceOS apps inherit from.","title":"Declaring Your App"},{"location":"Develop-Apps/01-manifest/#typical-app-structure","text":"Apps are usually located in Applications , inside of the game folder, and have the file extension .aosapp . Inside of the file, a Ren'Py script help determine details about the app, and a Resources folder is included to add assets such as icons, images, and definitions. For instance, if we are creating an app call Foobanizer , the structure would look like this: game / Applications / Foobanizer . aosapp / Foobanizer . rpy Resources / Iconset / 16 . png 24 . png 32 . png 48 . png 64 . png 128 . png 256 . png Note that the icons are located in Resources/Iconset/ and have sizes for 16px, 24px, 32px, 48px, 64px, 128px, and 256px. These icons are important as they will appear in notifications, the desktop, and other places that require an icon.","title":"Typical app structure"},{"location":"Develop-Apps/01-manifest/#writing-your-apps-manifest","text":"AliceOS apps' manifests are included directly inside of their main app delegate, a subclass of ASAppRepresentative() . There are several important key field that should be directly written: bundleName : The name of the application. bundleId : The ID of the application in reverse domain name notation . bundleDir : The location of the application. By default, apps use AS_APPS_DIR + \" applicationname .aosapp/\" . bundleAuthor : The author or organization that developed the application. bundleVersion : The version of the application. bundleDescription : The description of the application. Agan, if we wanted to write Foobanizer's manifest, it'd look like this: init 10 python : class Foobanizer ( ASAppRepresentative ): bundleName = Foobanizer bundleId = app.aliceos.foobanizer bundleDir = AS_APPS_DIR + Foobanizer.aosapp/ bundleAuthor = AliceOS Developers bundleVersion = 1.0.0 bundleDescription = \\ Generate random foobanized strings on the fly. ...","title":"Writing your app's manifest"},{"location":"Develop-Apps/01-manifest/#declaring-permissions","text":"Apps that need to make use of notifications via NotificationKit, modify files, watch system events, etc., must declare their permissions. This is done inside of the class via the requires dictionary: requires = { } The main permissions are: AS_REQUIRES_NOTIFICATIONKIT : Requires NotificationKit to send notifications AS_REQUIRES_FULL_DISK_ACCESS : Requires accessing files AS_REQUIRES_SYSTEM_EVENTS : Requires changing settings or watching for events Important All AppKit apps must include this field. If you don't need any permissions or aren't using specific frameworks, leave the dictionary empty. More information on permissions can be found accordingly: Declaring notification permissions","title":"Declaring permissions"},{"location":"Develop-Apps/01-manifest/#rebuilding-icons","text":"Icons for AliceOS apps typically reside in the app's Resources folder, though ASAppRepresentative may not pick it up at first. To ensure your app's icon locations are updated, make sure you initialize the class, where applicationname is the name of your app: def __init__ ( self ): ASAppRepresentative . __init__ ( self , AS_DEFAULT_APP_DIR + applicationname .aosapp/ ) Again, if we wanted to rebuild Foobanizer's icons: def __init__ ( self ): ASAppRepresentative . __init__ ( self , AS_APPS_DIR + Foobanizer.aosapp/ )","title":"Rebuilding icons"},{"location":"Develop-Apps/01-manifest/#example-manifest","text":"Here's what the manifest file for Foobanizer would look like: # ASAppRepresentative is a Python class. # Everything must be wrapped in a Python block. init 10 python : class Foobanizer ( ASAppRepresentative ): bundleName = Foobanizer bundleId = app.aliceos.foobanizer bundleDir = AS_APPS_DIR + Foobanizer.aosapp/ bundleAuthor = AliceOS Developers bundleVersion = 1.0.0 bundleDescription = \\ Generate random foobanized strings on the fly. # Foobanizer doesn t require any permissions. requires = { } def __init__ ( self ): ASAppRepresentative . __init__ ( self , AS_APPS_DIR + Foobanizer.aosapp/ ) # Finally, we create an instance to pre-load. foobanizer = Foobanizer ()","title":"Example manifest"},{"location":"Develop-Apps/02-sending-notifications/","text":"Sending Notifications Notifications are a great way to extend your visual novel project. If done correctly, they often can add an interactive experience that immerses players into the environment. Apps using AppKit have a way to send notification requests to the user that also respect's users' preferences. Declaring notification permissions Your app should have the proper permissions to send notifications via NotificationKit in the app's manifest. To ensure that your app lists itself as needing this permission, be sure to add AS_REQUIRES_NOTIFICATIONKIT into the requires field: requires = { AS_REQUIRES_NOTIFICATIONKIT , ... } Requesting for permission Typically, apps request for notification access before sending notification requests. There are two methods for handling this behavior: requestAllPermissions() will request for all permissions available. Use this only if notifications are dependent on other permissions that must be addressed immediately. requestPermission(forPermission=AS_REQUIRES_NOTIFICATIONKIT) will request specifically for the NotificationKit permission. Sending a temporary notification request Apps using AppKit have an official means of handling temporary notifications as banners via several methods. More details are provided on the Banners page . applicationShouldRequestNotification() This function is provided to check that the app has been given permission to send notifications. Returns Whether the app has been given permission to send notifications as a Boolean value. Danger Do not override this function unless you need to perform an additional check. applicationWillRequestNotification() Parameters message : The message or title of the notification. withDetails : The details of the notification. responseCallback (Optional) The action to perform when clicking 'Respond'. Tip If there are preliminary actions that should be performed before requesting a notification, you may redefine the function, granted that you also include ASAppRepresentative.applicationWillRequestNotification() . Example def applicationWillRequestNotification ( self , message , withDetails , responseCallback ) : if not Error in message : ASAppRepresentative . applicationWillRequestNotification ( message , withDetails , responseCallback ) else : print (Err: + message + ) + withDetails Danger Do not use any other methods for sending temporary notifications that do not listen to applicationShouldRequestNotification() . All notifications should adhere to users' preference. applicationDidRequestNotification() applicationDidRequestNotification() runs after a notification has been sent. This can be used to watch for a particular action or to do something else.","title":"Sending Notifications"},{"location":"Develop-Apps/02-sending-notifications/#sending-notifications","text":"Notifications are a great way to extend your visual novel project. If done correctly, they often can add an interactive experience that immerses players into the environment. Apps using AppKit have a way to send notification requests to the user that also respect's users' preferences.","title":"Sending Notifications"},{"location":"Develop-Apps/02-sending-notifications/#declaring-notification-permissions","text":"Your app should have the proper permissions to send notifications via NotificationKit in the app's manifest. To ensure that your app lists itself as needing this permission, be sure to add AS_REQUIRES_NOTIFICATIONKIT into the requires field: requires = { AS_REQUIRES_NOTIFICATIONKIT , ... }","title":"Declaring notification permissions"},{"location":"Develop-Apps/02-sending-notifications/#requesting-for-permission","text":"Typically, apps request for notification access before sending notification requests. There are two methods for handling this behavior: requestAllPermissions() will request for all permissions available. Use this only if notifications are dependent on other permissions that must be addressed immediately. requestPermission(forPermission=AS_REQUIRES_NOTIFICATIONKIT) will request specifically for the NotificationKit permission.","title":"Requesting for permission"},{"location":"Develop-Apps/02-sending-notifications/#sending-a-temporary-notification-request","text":"Apps using AppKit have an official means of handling temporary notifications as banners via several methods. More details are provided on the Banners page .","title":"Sending a temporary notification request"},{"location":"Develop-Apps/02-sending-notifications/#applicationshouldrequestnotification","text":"This function is provided to check that the app has been given permission to send notifications. Returns Whether the app has been given permission to send notifications as a Boolean value. Danger Do not override this function unless you need to perform an additional check.","title":"applicationShouldRequestNotification()"},{"location":"Develop-Apps/02-sending-notifications/#applicationwillrequestnotification","text":"Parameters message : The message or title of the notification. withDetails : The details of the notification. responseCallback (Optional) The action to perform when clicking 'Respond'. Tip If there are preliminary actions that should be performed before requesting a notification, you may redefine the function, granted that you also include ASAppRepresentative.applicationWillRequestNotification() . Example def applicationWillRequestNotification ( self , message , withDetails , responseCallback ) : if not Error in message : ASAppRepresentative . applicationWillRequestNotification ( message , withDetails , responseCallback ) else : print (Err: + message + ) + withDetails Danger Do not use any other methods for sending temporary notifications that do not listen to applicationShouldRequestNotification() . All notifications should adhere to users' preference.","title":"applicationWillRequestNotification()"},{"location":"Develop-Apps/02-sending-notifications/#applicationdidrequestnotification","text":"applicationDidRequestNotification() runs after a notification has been sent. This can be used to watch for a particular action or to do something else.","title":"applicationDidRequestNotification()"},{"location":"Develop-Apps/10-ASAppRepresentative/","text":"ASAppRepresentative() ASAppRepresentative is the Python class responsible for defining apps in AliceOS. The following documentation covers all of the methods and properties of this class. Properties bundleName : The name of the application. bundleId : The ID of the application in reverse domain name notation . bundleDir : The location of the application. By default, apps use AS_APPS_DIR + \" applicationname .aosapp/\" . bundleAuthor : The author or organization that developed the application. bundleVersion : The version of the application. bundleDescription : The description of the application. requires : A dictionary containing all of the permissions needed for the app to function. icons : A dictionary containing the paths of all icons for the appropriate sizes. Methods __init__(appDirectory) Constructs an instance of ASAppRepresentative . Parameters appDirectory : The directory of which the app is located. Equivalent to bundleDir . requestPermission(forPermission) Requests a particular permission located in requires . Parameters forPermission : The permission to request. Must be in requires to execute. requestAllPermissions() Requests all permissions located in requires , one by one. applicationShouldLaunchAtLogin() Returns whether the app is authorized to run any login tasks. applicationWillLaunchAtLogin() Executes and preliminary actions during the boot sequence. applicationWillLaunch() Executes any preliminary actions before the app launches. applicationDidLaunch() Executes post-launch actions after the app has launched. applicationWillTerminate() Executes cleanup actions before the app closes. applicationDidTerminate() Executes any tasks before finally closing. applicationShouldRequestNotification() Return whether the app is authorized to send notifications. Returns Boolean value dictating whether the app includes the notification permission and has permission to send notifications from the user. applicationWillRequestNotification(message, withDetails, responseCallback) Executes any pre-processing for a notification request and then sends a request. Parameters message : The message or title of the notification. withDetails : The details of the notification. responseCallback (Optional) The action to perform when clicking 'Respond'. applicationDidRequestNotification() Executes any actions after sending a notification request. applicationWillRequestBasicAlert(message, withDetails, onDismissCallback) Executes any pre-processing for an alert and then sends an alert request. Parameters message : The message or title of the alert. withDetails : The details of the alert. onDismissCallback (Optional) The action to perform when clicking 'OK'. applicationWillRequestExtendedAlert(message, withDetails, primaryActionText, onPrimaryCallback, secondaryActionText, onSecondaryCallback) Executes any pre-processing for an extended alert and then sends an alert request. message : The message or title of the alert. withDetails : The details of the alert. primaryActionText : The text for the primary action button onPrimaryCallback (Optional) The action to perform when clicking the primary button. secondaryActionText : (Optional) The text for the secondary action button onSecondaryCallback (Optional) The action to perform when clicking the secondary button. applicationDidRequestAlert() Executes any actions after sending an alert.","title":"ASAppRepresentative()"},{"location":"Develop-Apps/10-ASAppRepresentative/#asapprepresentative","text":"ASAppRepresentative is the Python class responsible for defining apps in AliceOS. The following documentation covers all of the methods and properties of this class.","title":"ASAppRepresentative()"},{"location":"Develop-Apps/10-ASAppRepresentative/#properties","text":"bundleName : The name of the application. bundleId : The ID of the application in reverse domain name notation . bundleDir : The location of the application. By default, apps use AS_APPS_DIR + \" applicationname .aosapp/\" . bundleAuthor : The author or organization that developed the application. bundleVersion : The version of the application. bundleDescription : The description of the application. requires : A dictionary containing all of the permissions needed for the app to function. icons : A dictionary containing the paths of all icons for the appropriate sizes.","title":"Properties"},{"location":"Develop-Apps/10-ASAppRepresentative/#methods","text":"","title":"Methods"},{"location":"Develop-Apps/10-ASAppRepresentative/#__init__appdirectory","text":"Constructs an instance of ASAppRepresentative . Parameters appDirectory : The directory of which the app is located. Equivalent to bundleDir .","title":"__init__(appDirectory)"},{"location":"Develop-Apps/10-ASAppRepresentative/#requestpermissionforpermission","text":"Requests a particular permission located in requires . Parameters forPermission : The permission to request. Must be in requires to execute.","title":"requestPermission(forPermission)"},{"location":"Develop-Apps/10-ASAppRepresentative/#requestallpermissions","text":"Requests all permissions located in requires , one by one.","title":"requestAllPermissions()"},{"location":"Develop-Apps/10-ASAppRepresentative/#applicationshouldlaunchatlogin","text":"Returns whether the app is authorized to run any login tasks.","title":"applicationShouldLaunchAtLogin()"},{"location":"Develop-Apps/10-ASAppRepresentative/#applicationwilllaunchatlogin","text":"Executes and preliminary actions during the boot sequence.","title":"applicationWillLaunchAtLogin()"},{"location":"Develop-Apps/10-ASAppRepresentative/#applicationwilllaunch","text":"Executes any preliminary actions before the app launches.","title":"applicationWillLaunch()"},{"location":"Develop-Apps/10-ASAppRepresentative/#applicationdidlaunch","text":"Executes post-launch actions after the app has launched.","title":"applicationDidLaunch()"},{"location":"Develop-Apps/10-ASAppRepresentative/#applicationwillterminate","text":"Executes cleanup actions before the app closes.","title":"applicationWillTerminate()"},{"location":"Develop-Apps/10-ASAppRepresentative/#applicationdidterminate","text":"Executes any tasks before finally closing.","title":"applicationDidTerminate()"},{"location":"Develop-Apps/10-ASAppRepresentative/#applicationshouldrequestnotification","text":"Return whether the app is authorized to send notifications. Returns Boolean value dictating whether the app includes the notification permission and has permission to send notifications from the user.","title":"applicationShouldRequestNotification()"},{"location":"Develop-Apps/10-ASAppRepresentative/#applicationwillrequestnotificationmessage-withdetails-responsecallback","text":"Executes any pre-processing for a notification request and then sends a request. Parameters message : The message or title of the notification. withDetails : The details of the notification. responseCallback (Optional) The action to perform when clicking 'Respond'.","title":"applicationWillRequestNotification(message, withDetails, responseCallback)"},{"location":"Develop-Apps/10-ASAppRepresentative/#applicationdidrequestnotification","text":"Executes any actions after sending a notification request.","title":"applicationDidRequestNotification()"},{"location":"Develop-Apps/10-ASAppRepresentative/#applicationwillrequestbasicalertmessage-withdetails-ondismisscallback","text":"Executes any pre-processing for an alert and then sends an alert request. Parameters message : The message or title of the alert. withDetails : The details of the alert. onDismissCallback (Optional) The action to perform when clicking 'OK'.","title":"applicationWillRequestBasicAlert(message, withDetails, onDismissCallback)"},{"location":"Develop-Apps/10-ASAppRepresentative/#applicationwillrequestextendedalertmessage-withdetails-primaryactiontext-onprimarycallback-secondaryactiontext-onsecondarycallback","text":"Executes any pre-processing for an extended alert and then sends an alert request. message : The message or title of the alert. withDetails : The details of the alert. primaryActionText : The text for the primary action button onPrimaryCallback (Optional) The action to perform when clicking the primary button. secondaryActionText : (Optional) The text for the secondary action button onSecondaryCallback (Optional) The action to perform when clicking the secondary button.","title":"applicationWillRequestExtendedAlert(message, withDetails, primaryActionText, onPrimaryCallback, secondaryActionText, onSecondaryCallback)"},{"location":"Develop-Apps/10-ASAppRepresentative/#applicationdidrequestalert","text":"Executes any actions after sending an alert.","title":"applicationDidRequestAlert()"},{"location":"Frameworks/NotificationKit/","text":"NotificationKit Overview NotificationKit is the official API set for sending notifications in AliceOS. Notifications include the following: Banners : Temporary popups from the top of the screen that can be acted upon or dismissed. Alerts : Full-screen dialog boxes that require user input immediately. Sounds: Sounds that play to incidate something has occured. About this documentation section The documentation provided on NotificationKit does not cover usage of their implementation with apps. Rather, the documentation covers the screens in use and how they can be called without needing Applets. This kind of scenario applies in cases where the AliceOS base only includes NotificationKit. If you wish to create an app that makes use of NotificationKit, please consult the Apps documentation under \"Sending Notifications\".","title":"NotificationKit Overview"},{"location":"Frameworks/NotificationKit/#notificationkit-overview","text":"NotificationKit is the official API set for sending notifications in AliceOS. Notifications include the following: Banners : Temporary popups from the top of the screen that can be acted upon or dismissed. Alerts : Full-screen dialog boxes that require user input immediately. Sounds: Sounds that play to incidate something has occured.","title":"NotificationKit Overview"},{"location":"Frameworks/NotificationKit/#about-this-documentation-section","text":"The documentation provided on NotificationKit does not cover usage of their implementation with apps. Rather, the documentation covers the screens in use and how they can be called without needing Applets. This kind of scenario applies in cases where the AliceOS base only includes NotificationKit. If you wish to create an app that makes use of NotificationKit, please consult the Apps documentation under \"Sending Notifications\".","title":"About this documentation section"},{"location":"Frameworks/NotificationKit/01-banner/","text":"Banners Banners provide a temporary pop-up at the top of the screen that automatically dismiss after five seconds. Banners usually include an app's name, primary message, details, and a response callback upon clicking 'Respond'. ASNotificationBanner() ASNotificationBanner(applet=None, message, withDetails, responseCallback=Return('didClickRespond')) Parameters applet : (Optional) The app object to pass in. If None, the app icon and bundle name on the top will display as \"Unknown Bundle\". message : (Required) The main message or sender. withDetails : (Required) The details of the message. responseCallback (Optional) The action to run upon clicking \"Respond\". Returns If the notification times out and dismisses, the banner will return 'notificationTimedOut' . If the notification's response callback is left as the default, the banner will return 'didClickRespond' when clicking the \"Respond\" button. Guidelines Banners are intended for temporary actions that can be ignored, if possible. Keep these guidelines in mind when using banners: Refrain from overloading banners . This can be visually distracting and may annoy the user. Keep the message and details short . Banners are intended for a quick glance or something that doesn't require a lot of attention. Don't force the user to interact with the banner . Banners shouldn't require the user to perform an action.","title":"Banners"},{"location":"Frameworks/NotificationKit/01-banner/#banners","text":"Banners provide a temporary pop-up at the top of the screen that automatically dismiss after five seconds. Banners usually include an app's name, primary message, details, and a response callback upon clicking 'Respond'.","title":"Banners"},{"location":"Frameworks/NotificationKit/01-banner/#asnotificationbanner","text":"ASNotificationBanner(applet=None, message, withDetails, responseCallback=Return('didClickRespond'))","title":"ASNotificationBanner()"},{"location":"Frameworks/NotificationKit/01-banner/#parameters","text":"applet : (Optional) The app object to pass in. If None, the app icon and bundle name on the top will display as \"Unknown Bundle\". message : (Required) The main message or sender. withDetails : (Required) The details of the message. responseCallback (Optional) The action to run upon clicking \"Respond\".","title":"Parameters"},{"location":"Frameworks/NotificationKit/01-banner/#returns","text":"If the notification times out and dismisses, the banner will return 'notificationTimedOut' . If the notification's response callback is left as the default, the banner will return 'didClickRespond' when clicking the \"Respond\" button.","title":"Returns"},{"location":"Frameworks/NotificationKit/01-banner/#guidelines","text":"Banners are intended for temporary actions that can be ignored, if possible. Keep these guidelines in mind when using banners: Refrain from overloading banners . This can be visually distracting and may annoy the user. Keep the message and details short . Banners are intended for a quick glance or something that doesn't require a lot of attention. Don't force the user to interact with the banner . Banners shouldn't require the user to perform an action.","title":"Guidelines"},{"location":"Frameworks/NotificationKit/02-alerts/","text":"Alerts Alerts provide important information for the user and request an immediate action. There are two types of alerts AliceOS has: basic and extended. Both types of alerts are designed to request an immediate action, though there are different uses for each alert type. ASNotificationAlert() (Basic) ASNotificationAlert(message, withDetails, onDismissCallback=Return('didDismissAlert')) Parameters message : The message or title of the alert. withDetails : The details of the alert. onDismissCallback (Optional) The action to perform when clicking 'OK'. Returns If the onDismissCallback remains at the default, the alert returns 'didDismissAlert' . ASNotificationExtendedAlert() (Extended) ASNotificationExtendedAlert(message, withDetails, primaryActionText, onPrimaryCallback=Return('didClickPrimary'), secondaryActionText=None, onSecondaryCallback=Return('didClickSecondary')) Parameters message : The message or title of the alert. withDetails : The details of the alert. primaryActionText : The text for the primary action button onPrimaryCallback (Optional) The action to perform when clicking the primary button. secondaryActionText : (Optional) The text for the secondary action button. If set to None , the secondary action button will not be displayed. onSecondaryCallback (Optional) The action to perform when clicking the secondary button. Returns If the user clicks the primary action button and the action callback is left at the default, the alert returns 'didClickPrimary' . Likewise, if the user clicks the secondary action button and the action callback is left at the default, the alert returns 'didClickSecondary' . Guidelines Refrain from overloading alerts. Alerts can be seen as intrivusive if too many are displayed at one time. Unless the user needs to make an immediate decision, refrain from using an alert. If the content isn't important, consider a banner. Banners are less intrusive by nature and don't require an immediate action.","title":"Alerts"},{"location":"Frameworks/NotificationKit/02-alerts/#alerts","text":"Alerts provide important information for the user and request an immediate action. There are two types of alerts AliceOS has: basic and extended. Both types of alerts are designed to request an immediate action, though there are different uses for each alert type.","title":"Alerts"},{"location":"Frameworks/NotificationKit/02-alerts/#asnotificationalert-basic","text":"ASNotificationAlert(message, withDetails, onDismissCallback=Return('didDismissAlert'))","title":"ASNotificationAlert() (Basic)"},{"location":"Frameworks/NotificationKit/02-alerts/#parameters","text":"message : The message or title of the alert. withDetails : The details of the alert. onDismissCallback (Optional) The action to perform when clicking 'OK'.","title":"Parameters"},{"location":"Frameworks/NotificationKit/02-alerts/#returns","text":"If the onDismissCallback remains at the default, the alert returns 'didDismissAlert' .","title":"Returns"},{"location":"Frameworks/NotificationKit/02-alerts/#asnotificationextendedalert-extended","text":"ASNotificationExtendedAlert(message, withDetails, primaryActionText, onPrimaryCallback=Return('didClickPrimary'), secondaryActionText=None, onSecondaryCallback=Return('didClickSecondary'))","title":"ASNotificationExtendedAlert() (Extended)"},{"location":"Frameworks/NotificationKit/02-alerts/#parameters_1","text":"message : The message or title of the alert. withDetails : The details of the alert. primaryActionText : The text for the primary action button onPrimaryCallback (Optional) The action to perform when clicking the primary button. secondaryActionText : (Optional) The text for the secondary action button. If set to None , the secondary action button will not be displayed. onSecondaryCallback (Optional) The action to perform when clicking the secondary button.","title":"Parameters"},{"location":"Frameworks/NotificationKit/02-alerts/#returns_1","text":"If the user clicks the primary action button and the action callback is left at the default, the alert returns 'didClickPrimary' . Likewise, if the user clicks the secondary action button and the action callback is left at the default, the alert returns 'didClickSecondary' .","title":"Returns"},{"location":"Frameworks/NotificationKit/02-alerts/#guidelines","text":"Refrain from overloading alerts. Alerts can be seen as intrivusive if too many are displayed at one time. Unless the user needs to make an immediate decision, refrain from using an alert. If the content isn't important, consider a banner. Banners are less intrusive by nature and don't require an immediate action.","title":"Guidelines"},{"location":"Frameworks/ScreenKit/","text":"ScreenKit Overview ScreenKit is the official API that offer beautiful interfaces for AliceOS apps and services. ScreenKit works on top of Ren'Py's beautiful screen language with new styles and puts more control of the interface into developers' hands. Apps using AppKit get to leverage ScreenKit easily without adding any additional code to their manifest. Warning ScreenKit is still heavy in development and styles may change over time. The API and documentation may change over time as ScreenKit matures. About this documentation section This section will go over the different aspects of ScreenKit and how a ScreenKit interface is constructed using Ren'Py's screen language.","title":"ScreenKit Overview"},{"location":"Frameworks/ScreenKit/#screenkit-overview","text":"ScreenKit is the official API that offer beautiful interfaces for AliceOS apps and services. ScreenKit works on top of Ren'Py's beautiful screen language with new styles and puts more control of the interface into developers' hands. Apps using AppKit get to leverage ScreenKit easily without adding any additional code to their manifest. Warning ScreenKit is still heavy in development and styles may change over time. The API and documentation may change over time as ScreenKit matures.","title":"ScreenKit Overview"},{"location":"Frameworks/ScreenKit/#about-this-documentation-section","text":"This section will go over the different aspects of ScreenKit and how a ScreenKit interface is constructed using Ren'Py's screen language.","title":"About this documentation section"},{"location":"Frameworks/ScreenKit/01-a-simple-ui/","text":"A Simple UI ScreenKit works beautifully with Ren'Py's screen language, a mostly-declarative and direct means of defining screens. Most of ScreenKit's UI magic works in such a way where, most of the time, you'll only need to add one extra line to your existing screen. Tip All of the examples provided in the documentation will use screen language instead of dynamic creation with Python. If you are unfamiliar with Ren'Py's screen language, we recommend that you read about it and how it works on the official documentation. Get started Creating a simple UI For this simple example, we'll create the UI seen at the top of this documentation page as part of an app called \"Samples\". The screen includes a few elements: Window title bar with window controls Vertical box with text and a button To get started, we'll need to first define our screen. Generally, AliceOS screen naming conventions follow that of the app's class: screen SamplesAppView (): We also have provided an empty parameter list since later versions of Ren'Py require a parameter list. Now that we've created the screen itself, we'll need to tell it to use ScreenKit to style the elements; otherwise, the screen will use the default GUI included in the visual novel. To do this, we need to set the screen's style_prefix , meaning that any styles in this screen are named starting with ASInterface . screen SamplesAppView (): style_prefix ASInterface Now that we have created a blank screen, we'll need to define a window frame, where the contents of the interface will be stored, as well as its maximum size: screen SamplesAppView (): style_prefix ASInterface frame : xalign 0 . 5 # Align it to the middle of the display yalign 0 . 5 # Align it to the center of the display xmaximum 700 # This is the biggest the frame can get ymaximum 600 # This is the tallest the frame can get The frame will now appear in the center of the display and will be at most 700 pixels wide and 600 pixels tall. By default, most ScreenKit UIs will be at most 1248 pixels wide and 688 pixels tall. Warning UIs built with ScreenKit should not be bigger than the maximum size of the game window (1280 pixels wide and 720 pixels tall). If it goes beyond this limit, the interface may get cut off. Now that we have a frame in place, we need to create the area where the content will appear. To do so, we'll need to create a vertical box: screen SamplesAppView (): style_prefix ASInterface frame : xalign 0 . 5 yalign 0 . 5 xmaximum 700 ymaximum 600 has vbox : xalign 0 . 5 yalign 0 . 5 Any content inside of the has vbox statement will appear inside of the vertical box and not interfere with anything else. We can now try to attach our screen to our SamplesApp by telling it to show the screen when the application is open under the app's applicationWillLaunch method in the manifest: def applicationWillLaunch ( self ): renpy . show_screen ( SamplesAppView ) return Note We used the method renpy.show_screen to show this screen rather than renpy.call_screen . If the app is launched while in an existing screen like the AliceOS Desktop, Ren'Py won't be able to call it because it would interrupt the current screen's interaction. However, you can get around this by using renpy.invoke_in_new_context so that the screen is in a different context from the default: renpy . invoke_in_new_context ( renpy . call_screen , SamplesAppView ) This method will also allow any return values to be passed in. After launching the app in either the Desktop or from App Manager, we can see that a frame is visible, but there isn't a title bar, and you can't exit the screen. To fix this, we'll need to call ASInterfaceTitlebar , a screen component: screen SamplesAppView (): style_prefix ASInterface frame : xalign 0 . 5 yalign 0 . 5 xmaximum 700 ymaximum 600 has vbox : xalign 0 . 5 yalign 0 . 5 use ASInterfaceTitlebar ( Sample Application , onClose = Hide ( SamplesAppView )) When we launch the application again this time, we will see our title bar and can click the close button to close out of the screen. Note In our onClose parameter, we specified the Hide screen action rather than Return . Since we didn't call the screen from a new context, we opted for Hide since it would hide the screen without closing out of the AliceOS desktop. Adding content to our UI Now we've set up a basic interface, we can start adding the rest of the interface, what we'll call the content . Since we're making just a basic interface, we can just add the text and our button inside of the vbox : ... # This is inside the screen from before has vbox : xalign 0 . 5 yalign 0 . 5 use ASInterfaceTitlebar ( Sample Application , onClose = Hide ( SamplesAppView )) text \\Welcome to this sample application! The view you are looking at works directly with ScreenKit to make a beautiful interface while still using Ren Py s screen language. hbox : xalign 1 . 0 yalign 1 . 0 textbutton Cool beans! action Hide ( SamplesAppView ) : style ASInterfacePushButton Note that for our push button, we wrapped it in a horizontal box ( hbox ) and added xalign 1.0 to move all the items to the right, as well as yalign 1.0 to keep them at the bottom of the window. This can be useful if you have multiple buttons and want to keep them at the right. Also, for the push button, we added an additional style property to the push button style, ASInterfacePushButton . This lets us use the AliceOS style for push buttons; otherwise, they would default to the text buttons AliceOS uses. Now we can open the application and verify that it looks exactly the way we want and that clicking \"Cool beans!\" closes the window as expected. Finished code Here is the final code for our screen: screen SamplesAppView () : style_prefix ASInterface frame : xalign 0 . 5 yalign 0 . 5 xmaximum 700 ymaximum 600 has vbox : xalign 0 . 5 yalign 0 . 5 use ASInterfaceTitlebar ( Sample Application , onClose = Hide ( SamplesAppView )) text \\Welcome to this sample application! The view you are looking at works directly with ScreenKit to make a beautiful interface while still using Ren Py s screen language. hbox : xalign 1 . 0 yalign 1 . 0 textbutton Cool beans! action Hide ( SamplesAppView ) : style ASInterfacePushButton","title":"A Simple UI"},{"location":"Frameworks/ScreenKit/01-a-simple-ui/#a-simple-ui","text":"ScreenKit works beautifully with Ren'Py's screen language, a mostly-declarative and direct means of defining screens. Most of ScreenKit's UI magic works in such a way where, most of the time, you'll only need to add one extra line to your existing screen. Tip All of the examples provided in the documentation will use screen language instead of dynamic creation with Python. If you are unfamiliar with Ren'Py's screen language, we recommend that you read about it and how it works on the official documentation. Get started","title":"A Simple UI"},{"location":"Frameworks/ScreenKit/01-a-simple-ui/#creating-a-simple-ui","text":"For this simple example, we'll create the UI seen at the top of this documentation page as part of an app called \"Samples\". The screen includes a few elements: Window title bar with window controls Vertical box with text and a button To get started, we'll need to first define our screen. Generally, AliceOS screen naming conventions follow that of the app's class: screen SamplesAppView (): We also have provided an empty parameter list since later versions of Ren'Py require a parameter list. Now that we've created the screen itself, we'll need to tell it to use ScreenKit to style the elements; otherwise, the screen will use the default GUI included in the visual novel. To do this, we need to set the screen's style_prefix , meaning that any styles in this screen are named starting with ASInterface . screen SamplesAppView (): style_prefix ASInterface Now that we have created a blank screen, we'll need to define a window frame, where the contents of the interface will be stored, as well as its maximum size: screen SamplesAppView (): style_prefix ASInterface frame : xalign 0 . 5 # Align it to the middle of the display yalign 0 . 5 # Align it to the center of the display xmaximum 700 # This is the biggest the frame can get ymaximum 600 # This is the tallest the frame can get The frame will now appear in the center of the display and will be at most 700 pixels wide and 600 pixels tall. By default, most ScreenKit UIs will be at most 1248 pixels wide and 688 pixels tall. Warning UIs built with ScreenKit should not be bigger than the maximum size of the game window (1280 pixels wide and 720 pixels tall). If it goes beyond this limit, the interface may get cut off. Now that we have a frame in place, we need to create the area where the content will appear. To do so, we'll need to create a vertical box: screen SamplesAppView (): style_prefix ASInterface frame : xalign 0 . 5 yalign 0 . 5 xmaximum 700 ymaximum 600 has vbox : xalign 0 . 5 yalign 0 . 5 Any content inside of the has vbox statement will appear inside of the vertical box and not interfere with anything else. We can now try to attach our screen to our SamplesApp by telling it to show the screen when the application is open under the app's applicationWillLaunch method in the manifest: def applicationWillLaunch ( self ): renpy . show_screen ( SamplesAppView ) return Note We used the method renpy.show_screen to show this screen rather than renpy.call_screen . If the app is launched while in an existing screen like the AliceOS Desktop, Ren'Py won't be able to call it because it would interrupt the current screen's interaction. However, you can get around this by using renpy.invoke_in_new_context so that the screen is in a different context from the default: renpy . invoke_in_new_context ( renpy . call_screen , SamplesAppView ) This method will also allow any return values to be passed in. After launching the app in either the Desktop or from App Manager, we can see that a frame is visible, but there isn't a title bar, and you can't exit the screen. To fix this, we'll need to call ASInterfaceTitlebar , a screen component: screen SamplesAppView (): style_prefix ASInterface frame : xalign 0 . 5 yalign 0 . 5 xmaximum 700 ymaximum 600 has vbox : xalign 0 . 5 yalign 0 . 5 use ASInterfaceTitlebar ( Sample Application , onClose = Hide ( SamplesAppView )) When we launch the application again this time, we will see our title bar and can click the close button to close out of the screen. Note In our onClose parameter, we specified the Hide screen action rather than Return . Since we didn't call the screen from a new context, we opted for Hide since it would hide the screen without closing out of the AliceOS desktop.","title":"Creating a simple UI"},{"location":"Frameworks/ScreenKit/01-a-simple-ui/#adding-content-to-our-ui","text":"Now we've set up a basic interface, we can start adding the rest of the interface, what we'll call the content . Since we're making just a basic interface, we can just add the text and our button inside of the vbox : ... # This is inside the screen from before has vbox : xalign 0 . 5 yalign 0 . 5 use ASInterfaceTitlebar ( Sample Application , onClose = Hide ( SamplesAppView )) text \\Welcome to this sample application! The view you are looking at works directly with ScreenKit to make a beautiful interface while still using Ren Py s screen language. hbox : xalign 1 . 0 yalign 1 . 0 textbutton Cool beans! action Hide ( SamplesAppView ) : style ASInterfacePushButton Note that for our push button, we wrapped it in a horizontal box ( hbox ) and added xalign 1.0 to move all the items to the right, as well as yalign 1.0 to keep them at the bottom of the window. This can be useful if you have multiple buttons and want to keep them at the right. Also, for the push button, we added an additional style property to the push button style, ASInterfacePushButton . This lets us use the AliceOS style for push buttons; otherwise, they would default to the text buttons AliceOS uses. Now we can open the application and verify that it looks exactly the way we want and that clicking \"Cool beans!\" closes the window as expected.","title":"Adding content to our UI"},{"location":"Frameworks/ScreenKit/01-a-simple-ui/#finished-code","text":"Here is the final code for our screen: screen SamplesAppView () : style_prefix ASInterface frame : xalign 0 . 5 yalign 0 . 5 xmaximum 700 ymaximum 600 has vbox : xalign 0 . 5 yalign 0 . 5 use ASInterfaceTitlebar ( Sample Application , onClose = Hide ( SamplesAppView )) text \\Welcome to this sample application! The view you are looking at works directly with ScreenKit to make a beautiful interface while still using Ren Py s screen language. hbox : xalign 1 . 0 yalign 1 . 0 textbutton Cool beans! action Hide ( SamplesAppView ) : style ASInterfacePushButton","title":"Finished code"},{"location":"Frameworks/ScreenKit/02-special-styles/","text":"Special ScreenKit Styles Not all ScreenKit elements can be easily inherited via the style prefix. To accommodate for this, ScreenKit also includes some special styles that must be applied to an interface element specifically. Text Buttons The following styles apply to text buttons ( textbutton ). These styles can also be used as a style prefix when in a hbox or a vbox . ASInterfacePushButton The base style for a push button. ASInterfaceCheckbox The base style for a checkbox. Scrollable Content The following styles apply to scrollable areas where a scrollbar is present. ASInterfaceScrollbar The base style for a vertically-scrolling area. Used with viewport . Can be used as a style prefix.","title":"Special ScreenKit Styles"},{"location":"Frameworks/ScreenKit/02-special-styles/#special-screenkit-styles","text":"Not all ScreenKit elements can be easily inherited via the style prefix. To accommodate for this, ScreenKit also includes some special styles that must be applied to an interface element specifically.","title":"Special ScreenKit Styles"},{"location":"Frameworks/ScreenKit/02-special-styles/#text-buttons","text":"The following styles apply to text buttons ( textbutton ). These styles can also be used as a style prefix when in a hbox or a vbox .","title":"Text Buttons"},{"location":"Frameworks/ScreenKit/02-special-styles/#asinterfacepushbutton","text":"The base style for a push button.","title":"ASInterfacePushButton"},{"location":"Frameworks/ScreenKit/02-special-styles/#asinterfacecheckbox","text":"The base style for a checkbox.","title":"ASInterfaceCheckbox"},{"location":"Frameworks/ScreenKit/02-special-styles/#scrollable-content","text":"The following styles apply to scrollable areas where a scrollbar is present.","title":"Scrollable Content"},{"location":"Frameworks/ScreenKit/02-special-styles/#asinterfacescrollbar","text":"The base style for a vertically-scrolling area. Used with viewport . Can be used as a style prefix.","title":"ASInterfaceScrollbar"},{"location":"Release-Notes/","text":"Prospect Park (2.0.0) Developer Beta 2 The following document covers the latest changes in AliceOS Prospect Park (v. 2.0.0). Apps Apps can now write starup/login services via applicationWillLaunchAtLogin() and check for System Events permissions with applicationShouldLaunchAtLogin() . Notfications and alerts in AppKit are now invoked in a new context instead of interrupting the current one. The 48 pixel icon entry in ASAppRepresentative has been re-added. If unimplemented, applicationWillLaunch() will log a warning in the terminal. Messages Messages now displays a \"Coming Soon\" alert when launched from the Desktop. Desktop Apps on the desktop will invoke applicationWillLaunch as a Ren'Py function callback instead of calling the Python function directly to prevent continuous calls. The main views in Desktop now have empty parameter lists to resolve linter warnings. Known Issues The Desktop doesn't hide the quick menu. The showDesktop() method from ASDesktop doesn't work in Ren'Py screen language when calling it as a button action. Workarounds Use Ren'Py's Function call to run showDesktop() or make a call directly to the screen. Notifications Known issues Notification banners do not make a sound. Workarounds Include a sound in your applet and make a wrapper around applicationWillRequestNotification() . Bootloader The bootloader will now attempt to run any authorized startup services in a new thread. An optional bootView parameter allows developers to set a custom boot screen to display instead of the default. ScreenKit ScreenKit has been introduced as a means of creating user interfaces for AliceOS using Ren'Py's screen language and styling. Styles for frames, vertical and horizontal boxes, text, checkbox buttons, vertical scrollbars, and push buttons have been implemented. ASInterfaceTitlebar has been implemented as a smaller component to add a title bar to a given frame. About AliceOS The main interface has been written entirely with ScreenKit and displays information from system definitions. App Manager App Manager has been introduced as a means of managing an app's permissions and viewing details about the app. Apps in App Manager list their permissions as toggleable checkboxes.","title":"Prospect Park (2.0.0) Developer Beta 2"},{"location":"Release-Notes/#prospect-park-200-developer-beta-2","text":"The following document covers the latest changes in AliceOS Prospect Park (v. 2.0.0).","title":"Prospect Park (2.0.0) Developer Beta 2"},{"location":"Release-Notes/#apps","text":"Apps can now write starup/login services via applicationWillLaunchAtLogin() and check for System Events permissions with applicationShouldLaunchAtLogin() . Notfications and alerts in AppKit are now invoked in a new context instead of interrupting the current one. The 48 pixel icon entry in ASAppRepresentative has been re-added. If unimplemented, applicationWillLaunch() will log a warning in the terminal.","title":"Apps"},{"location":"Release-Notes/#messages","text":"Messages now displays a \"Coming Soon\" alert when launched from the Desktop.","title":"Messages"},{"location":"Release-Notes/#desktop","text":"Apps on the desktop will invoke applicationWillLaunch as a Ren'Py function callback instead of calling the Python function directly to prevent continuous calls. The main views in Desktop now have empty parameter lists to resolve linter warnings.","title":"Desktop"},{"location":"Release-Notes/#known-issues","text":"The Desktop doesn't hide the quick menu. The showDesktop() method from ASDesktop doesn't work in Ren'Py screen language when calling it as a button action.","title":"Known Issues"},{"location":"Release-Notes/#workarounds","text":"Use Ren'Py's Function call to run showDesktop() or make a call directly to the screen.","title":"Workarounds"},{"location":"Release-Notes/#notifications","text":"","title":"Notifications"},{"location":"Release-Notes/#known-issues_1","text":"Notification banners do not make a sound.","title":"Known issues"},{"location":"Release-Notes/#workarounds_1","text":"Include a sound in your applet and make a wrapper around applicationWillRequestNotification() .","title":"Workarounds"},{"location":"Release-Notes/#bootloader","text":"The bootloader will now attempt to run any authorized startup services in a new thread. An optional bootView parameter allows developers to set a custom boot screen to display instead of the default.","title":"Bootloader"},{"location":"Release-Notes/#screenkit","text":"ScreenKit has been introduced as a means of creating user interfaces for AliceOS using Ren'Py's screen language and styling. Styles for frames, vertical and horizontal boxes, text, checkbox buttons, vertical scrollbars, and push buttons have been implemented. ASInterfaceTitlebar has been implemented as a smaller component to add a title bar to a given frame.","title":"ScreenKit"},{"location":"Release-Notes/#about-aliceos","text":"The main interface has been written entirely with ScreenKit and displays information from system definitions.","title":"About AliceOS"},{"location":"Release-Notes/#app-manager","text":"App Manager has been introduced as a means of managing an app's permissions and viewing details about the app. Apps in App Manager list their permissions as toggleable checkboxes.","title":"App Manager"},{"location":"Release-Notes/1tp1/","text":"Technical Preview 1 (1.0.0) This is the first initial release of AliceOS Technical Preview.","title":"Technical Preview 1 (1.0.0)"},{"location":"Release-Notes/1tp1/#technical-preview-1-100","text":"This is the first initial release of AliceOS Technical Preview.","title":"Technical Preview 1 (1.0.0)"},{"location":"Release-Notes/1tp2/","text":"Technical Preview 2 (1.0.0) Setup assistant has been completely rewritten from the ground-up. Now supports dynamic font changes and a large font mode. Stop errors have been rewritten and are now dynamically called using ThrowASError() Default backgrounds have changed. OEM settings have been adjusted to use the new Setup assistant and now use hardcoded values for font files instead of dynamic assignments. Issue where Ren'Py projects crash upon loading an AliceOS dialog from a save file in OEM font mode has been resolved (#22).","title":"Technical Preview 2 (1.0.0)"},{"location":"Release-Notes/1tp2/#technical-preview-2-100","text":"Setup assistant has been completely rewritten from the ground-up. Now supports dynamic font changes and a large font mode. Stop errors have been rewritten and are now dynamically called using ThrowASError() Default backgrounds have changed. OEM settings have been adjusted to use the new Setup assistant and now use hardcoded values for font files instead of dynamic assignments. Issue where Ren'Py projects crash upon loading an AliceOS dialog from a save file in OEM font mode has been resolved (#22).","title":"Technical Preview 2 (1.0.0)"},{"location":"Release-Notes/2.0.0_db1/","text":"Prospect Park (2.0.0) Developer Beta 1 The following document covers the latest changes in AliceOS Prospect Park (v. 2.0.0). This document is not complete More documentation is being worked on with this document to describe exact changes. Before you upgrade AliceOS Prospect Park is a dramatic overhaul of the classic AliceOS and may break upon installation. Please review everything carefully. General The system organization has migrated over to a macOS-styled directory structure with System, Library, and Applications. Installation has changed over to an RPA-based solution. Installation now is as simple as dragging the RPA. AliceOS APIs, class names, and function names have been renamed and switch over to camel case instead of snake case. Apps Applets have been deprecated in favor of new apps written with AppKit in mind. Apps no longer need to declare a desktop shell component as this is handled by the native applicationWillLaunch method. Core Services and Applications Applications such as Messages have been moved to System/Applications/ and use AppKit. The halt screen, bootloader, and Setup Assistant are now Core Services that use ServiceKit. Desktop The Desktop now uses the applicationWillLaunch method from AppKit apps to start apps accordingly. The Desktop image is defined as AS_DESKTOP_IMG . The Desktop now refreshes quickly to get the latest time on the clock. Known issues The Desktop doesn't hide the quick menu. The showDesktop() method from ASDesktop doesn't work in Ren'Py screen language. Workarounds Call ASDesktopShell directly instead of using the showDesktop() method. Halt screens (formerly Stop errors) The halt screen uses the AliceOS dynamic blur instead of its own background. A QR code has been added that redirects users to the AliceOS Error Database. The text has been changed to indicate how long before AliceOS will automatically restart the game. Notifications Notifications are now under the NotificationKit framework. Alerts no longer appear as a white square. They now use the AliceOS dynamic blur feature. Known issues Notification banners do not make a sound. Setup Assistant Express Mode is on by default, but can be disabled in the bootloader's boot method. Instructions have been rewritten for conciseness and clarity. The interface has changed to a more macOS-like experience.","title":"Prospect Park (2.0.0) Developer Beta 1"},{"location":"Release-Notes/2.0.0_db1/#prospect-park-200-developer-beta-1","text":"The following document covers the latest changes in AliceOS Prospect Park (v. 2.0.0). This document is not complete More documentation is being worked on with this document to describe exact changes. Before you upgrade AliceOS Prospect Park is a dramatic overhaul of the classic AliceOS and may break upon installation. Please review everything carefully.","title":"Prospect Park (2.0.0) Developer Beta 1"},{"location":"Release-Notes/2.0.0_db1/#general","text":"The system organization has migrated over to a macOS-styled directory structure with System, Library, and Applications. Installation has changed over to an RPA-based solution. Installation now is as simple as dragging the RPA. AliceOS APIs, class names, and function names have been renamed and switch over to camel case instead of snake case.","title":"General"},{"location":"Release-Notes/2.0.0_db1/#apps","text":"Applets have been deprecated in favor of new apps written with AppKit in mind. Apps no longer need to declare a desktop shell component as this is handled by the native applicationWillLaunch method.","title":"Apps"},{"location":"Release-Notes/2.0.0_db1/#core-services-and-applications","text":"Applications such as Messages have been moved to System/Applications/ and use AppKit. The halt screen, bootloader, and Setup Assistant are now Core Services that use ServiceKit.","title":"Core Services and Applications"},{"location":"Release-Notes/2.0.0_db1/#desktop","text":"The Desktop now uses the applicationWillLaunch method from AppKit apps to start apps accordingly. The Desktop image is defined as AS_DESKTOP_IMG . The Desktop now refreshes quickly to get the latest time on the clock.","title":"Desktop"},{"location":"Release-Notes/2.0.0_db1/#known-issues","text":"The Desktop doesn't hide the quick menu. The showDesktop() method from ASDesktop doesn't work in Ren'Py screen language.","title":"Known issues"},{"location":"Release-Notes/2.0.0_db1/#workarounds","text":"Call ASDesktopShell directly instead of using the showDesktop() method.","title":"Workarounds"},{"location":"Release-Notes/2.0.0_db1/#halt-screens-formerly-stop-errors","text":"The halt screen uses the AliceOS dynamic blur instead of its own background. A QR code has been added that redirects users to the AliceOS Error Database. The text has been changed to indicate how long before AliceOS will automatically restart the game.","title":"Halt screens (formerly Stop errors)"},{"location":"Release-Notes/2.0.0_db1/#notifications","text":"Notifications are now under the NotificationKit framework. Alerts no longer appear as a white square. They now use the AliceOS dynamic blur feature.","title":"Notifications"},{"location":"Release-Notes/2.0.0_db1/#known-issues_1","text":"Notification banners do not make a sound.","title":"Known issues"},{"location":"Release-Notes/2.0.0_db1/#setup-assistant","text":"Express Mode is on by default, but can be disabled in the bootloader's boot method. Instructions have been rewritten for conciseness and clarity. The interface has changed to a more macOS-like experience.","title":"Setup Assistant"},{"location":"System/01-definitions/","text":"AliceOS Definitions To make referencing common AliceOS build settings and structures easier, AliceOS provides the following definitions and dictionaries. These are located in System/ASDefinitions.rpy and can be modified if necessary. AliceOS release definitions These definitions are used to specify important release information regarding AliceOS. These definitions might be referenced to specify OS version information to the user, in a help screen, for example. This is stored as a dictionary in AS_SYS_INFO Definition name Used for VERSION The release version. Typically X.x.x ; this isn't the build number generated from the Git hash COMMON_NAME The common name for the release. (ex. \"Prospect Park\") BUILD_ID The build number as generated by the Git hash or the Travis tag Directory definitions Definition name Points to Used for AS_SYSTEM_DIR System/ The default System directory. AS_FRAMEWORKS_DIR System/Frameworks/ The default Frameworks directory. AS_CORESERVICES_DIR System/CoreServices/ The default Core Services directory. AS_DEFAULT_APP_DIR System/Applications/ The default System applications directory. This isn't necessary for developer use. AS_FONTS_DIR System/Fonts/ The default Fonts directory. AS_APPS_DIR Applications/ The default Applications directory. AS_LIBRARY_DIR System/Library/ The default Library directory. Framework directory definitions AS_FRAMEWORK_DIR(FRAMEWORK_NAME=\"Default\") The directory where a particular Framework is located. Makes use of AS_FRAMEWORKS_DIR . Parameters FRAMEWORK_NAME : The name of the framework to reference. Example: NotificationKit Returns The path to the framework. Example: System/Frameworks/NotificationKit.aosframework/ Permissions definitions These definitions are used to specify important strings when asking the user permission for a particular item. These are dictionaries that include the values for a particular permission. AS_REQUIRE_PERMS_NAME : The dictionary containing the name of the permission name. Example: \"Send Notifications\" AS_REQUIRE_PERMS_DESC : The dictionary containing the description of a permission. Example: \"Notifications may include banners, alerts, and sounds. These can be configured in Settings.\"","title":"AliceOS Definitions"},{"location":"System/01-definitions/#aliceos-definitions","text":"To make referencing common AliceOS build settings and structures easier, AliceOS provides the following definitions and dictionaries. These are located in System/ASDefinitions.rpy and can be modified if necessary.","title":"AliceOS Definitions"},{"location":"System/01-definitions/#aliceos-release-definitions","text":"These definitions are used to specify important release information regarding AliceOS. These definitions might be referenced to specify OS version information to the user, in a help screen, for example. This is stored as a dictionary in AS_SYS_INFO Definition name Used for VERSION The release version. Typically X.x.x ; this isn't the build number generated from the Git hash COMMON_NAME The common name for the release. (ex. \"Prospect Park\") BUILD_ID The build number as generated by the Git hash or the Travis tag","title":"AliceOS release definitions"},{"location":"System/01-definitions/#directory-definitions","text":"Definition name Points to Used for AS_SYSTEM_DIR System/ The default System directory. AS_FRAMEWORKS_DIR System/Frameworks/ The default Frameworks directory. AS_CORESERVICES_DIR System/CoreServices/ The default Core Services directory. AS_DEFAULT_APP_DIR System/Applications/ The default System applications directory. This isn't necessary for developer use. AS_FONTS_DIR System/Fonts/ The default Fonts directory. AS_APPS_DIR Applications/ The default Applications directory. AS_LIBRARY_DIR System/Library/ The default Library directory.","title":"Directory definitions"},{"location":"System/01-definitions/#framework-directory-definitions","text":"AS_FRAMEWORK_DIR(FRAMEWORK_NAME=\"Default\") The directory where a particular Framework is located. Makes use of AS_FRAMEWORKS_DIR . Parameters FRAMEWORK_NAME : The name of the framework to reference. Example: NotificationKit Returns The path to the framework. Example: System/Frameworks/NotificationKit.aosframework/","title":"Framework directory definitions"},{"location":"System/01-definitions/#permissions-definitions","text":"These definitions are used to specify important strings when asking the user permission for a particular item. These are dictionaries that include the values for a particular permission. AS_REQUIRE_PERMS_NAME : The dictionary containing the name of the permission name. Example: \"Send Notifications\" AS_REQUIRE_PERMS_DESC : The dictionary containing the description of a permission. Example: \"Notifications may include banners, alerts, and sounds. These can be configured in Settings.\"","title":"Permissions definitions"},{"location":"System/02-default-apps/","text":"Default Apps AliceOS includes several default applications that are located in System/Applications/ . These applications are designed to enhance the AliceOS experience and provide functionalities for core parts without having to write a third-party app for them. Messages Messages is a simple app designed to simulate text messaging between characters and the player in a fun way. Available methods messages.receiveMessage(fromPerson, message) Send a notification request that displays a text message from a person. Parameters fromPerson : The person the message is being sent from message : The text message being sent Returns Returns the default values as indicated from ASNotificationBanner About AliceOS About AliceOS is a simple app that displays information about the current distribution of AliceOS. Users can click on the app in Activites and view the information there. There are no available methods as the app uses the standard applicationWillLaunch method from AppKit. App Manager App Manager is a(n) utility in AliceOS that lets users view the apps installed on the AliceOS system and manage their permissions quickly. It is the official method of changing an app's permissions in AliceOS. There are no available methods as the app uses the standard applicationWillLaunch method from AppKit.","title":"Default Apps"},{"location":"System/02-default-apps/#default-apps","text":"AliceOS includes several default applications that are located in System/Applications/ . These applications are designed to enhance the AliceOS experience and provide functionalities for core parts without having to write a third-party app for them.","title":"Default Apps"},{"location":"System/02-default-apps/#messages","text":"Messages is a simple app designed to simulate text messaging between characters and the player in a fun way. Available methods messages.receiveMessage(fromPerson, message) Send a notification request that displays a text message from a person. Parameters fromPerson : The person the message is being sent from message : The text message being sent Returns Returns the default values as indicated from ASNotificationBanner","title":"Messages"},{"location":"System/02-default-apps/#about-aliceos","text":"About AliceOS is a simple app that displays information about the current distribution of AliceOS. Users can click on the app in Activites and view the information there. There are no available methods as the app uses the standard applicationWillLaunch method from AppKit.","title":"About AliceOS"},{"location":"System/02-default-apps/#app-manager","text":"App Manager is a(n) utility in AliceOS that lets users view the apps installed on the AliceOS system and manage their permissions quickly. It is the official method of changing an app's permissions in AliceOS. There are no available methods as the app uses the standard applicationWillLaunch method from AppKit.","title":"App Manager"},{"location":"System/03-core-services/","text":"Core Services AliceOS comes with several bundled Core Services that you should be aware of. These Core Services are crucial to AliceOS's core and are included in every AliceOS installation. Core Services are given the .aoscservice file extension and exist under System/CoreServices . Core services also make use of ServiceKit, an in-house framework for defining core services. About ServiceKit At all costs, do not remove ServiceKit.aosframework or attempt to write your own applications using ServiceKit. ServiceKit is a service-only API set that should be used for system-level utilities, not for third-party applications. Use AppKit instead. Desktop The Desktop Core Service is responsible for displaying current applications installed on the system as well as providing a desktop shell if necessary. Error Halt System The Error Halt System (Halt) Core Service is responsible for displaying any critical errors that cause AliceOS to restart. It provides helpful information such as the error code and where to go for more information. More information on how this Core Service works can be found on the article about Critical Errors . Bootloader The Bootloader is responsible for displaying a boot screen while important components are loading. The bootloader is cusomizable with a certain timeout, depending on how fast you want the OS to \"load\". If the Setup Assistant hasn't fired or completed, the bootloader will also load the Setup Assistant. Setup Assistant The Setup Assistant is responsible for setting up any important configurations and settings for AliceOS, as well as creating a username stored in persistent.playername and letting users read any legal agreements before playing a visual novel project. Removing a service If you find that you don't need a particular core service, you can delete it from the CoreServices directory and rebuild AliceOS. Warning If you plan to remove a Core Service, do so with caution. Other parts of AliceOS may make system calls that heavily rely on them.","title":"Core Services"},{"location":"System/03-core-services/#core-services","text":"AliceOS comes with several bundled Core Services that you should be aware of. These Core Services are crucial to AliceOS's core and are included in every AliceOS installation. Core Services are given the .aoscservice file extension and exist under System/CoreServices . Core services also make use of ServiceKit, an in-house framework for defining core services. About ServiceKit At all costs, do not remove ServiceKit.aosframework or attempt to write your own applications using ServiceKit. ServiceKit is a service-only API set that should be used for system-level utilities, not for third-party applications. Use AppKit instead.","title":"Core Services"},{"location":"System/03-core-services/#desktop","text":"The Desktop Core Service is responsible for displaying current applications installed on the system as well as providing a desktop shell if necessary.","title":"Desktop"},{"location":"System/03-core-services/#error-halt-system","text":"The Error Halt System (Halt) Core Service is responsible for displaying any critical errors that cause AliceOS to restart. It provides helpful information such as the error code and where to go for more information. More information on how this Core Service works can be found on the article about Critical Errors .","title":"Error Halt System"},{"location":"System/03-core-services/#bootloader","text":"The Bootloader is responsible for displaying a boot screen while important components are loading. The bootloader is cusomizable with a certain timeout, depending on how fast you want the OS to \"load\". If the Setup Assistant hasn't fired or completed, the bootloader will also load the Setup Assistant.","title":"Bootloader"},{"location":"System/03-core-services/#setup-assistant","text":"The Setup Assistant is responsible for setting up any important configurations and settings for AliceOS, as well as creating a username stored in persistent.playername and letting users read any legal agreements before playing a visual novel project.","title":"Setup Assistant"},{"location":"System/03-core-services/#removing-a-service","text":"If you find that you don't need a particular core service, you can delete it from the CoreServices directory and rebuild AliceOS. Warning If you plan to remove a Core Service, do so with caution. Other parts of AliceOS may make system calls that heavily rely on them.","title":"Removing a service"},{"location":"System/04-critical-errors/","text":"Critical Errors If AliceOS encounters a critical error where it needs to restart to continue, the user will see the above warning and the system will restart automatically after 10 seconds. An error code is provided at the bottom and a QR cose is present to search the error on the Error Database . Critical errors and the halt screen is managed by the Error Halt System (Halt), a Core Service and can be used to present errors that aren't already caught by the base AliceOS distribution. Displaying a halt To display the halt screen with a respective error code, call $ ASHalt.halt(\"ERR_CODE\") . The system will display the halt and automatically restart after ten seconds. Guidelines Halt screens should be used to catch important, critical errors. Make your error code descriptive. The user should be able to get an idea of what the problem might be from the error code itself. For instance, \" MISSING_CYANIDE_INSTRUMENT \" is more descriptive than \" INSTRUMENT_FAIL \". Make sure your error is searchable in the database. The user should be able to search for your error in the Error Database to investigate what went wrong. Don't call the halt screen for a non-critical error. The halt screen is designed to present immediate and important information to the user about a potential error that could damage AliceOS or your game in some way. It shouldn't be used to present an app-wide or section-wide error as the screen is rather intrusive.","title":"Critical Errors"},{"location":"System/04-critical-errors/#critical-errors","text":"If AliceOS encounters a critical error where it needs to restart to continue, the user will see the above warning and the system will restart automatically after 10 seconds. An error code is provided at the bottom and a QR cose is present to search the error on the Error Database . Critical errors and the halt screen is managed by the Error Halt System (Halt), a Core Service and can be used to present errors that aren't already caught by the base AliceOS distribution.","title":"Critical Errors"},{"location":"System/04-critical-errors/#displaying-a-halt","text":"To display the halt screen with a respective error code, call $ ASHalt.halt(\"ERR_CODE\") . The system will display the halt and automatically restart after ten seconds.","title":"Displaying a halt"},{"location":"System/04-critical-errors/#guidelines","text":"Halt screens should be used to catch important, critical errors. Make your error code descriptive. The user should be able to get an idea of what the problem might be from the error code itself. For instance, \" MISSING_CYANIDE_INSTRUMENT \" is more descriptive than \" INSTRUMENT_FAIL \". Make sure your error is searchable in the database. The user should be able to search for your error in the Error Database to investigate what went wrong. Don't call the halt screen for a non-critical error. The halt screen is designed to present immediate and important information to the user about a potential error that could damage AliceOS or your game in some way. It shouldn't be used to present an app-wide or section-wide error as the screen is rather intrusive.","title":"Guidelines"},{"location":"System/05-bootloader/","text":"Bootloader The bootloader is responsible for displaying a boot screen while important components are loading. The bootloader is cusomizable with a certain timeout, depending on how fast you want the OS to \"load\". Available methods $ ASBootloader.boot(timeout=5, expressSetup=True, disclaimer=None, bootView=\"ASBootloaderView\") Show the bootloader for a certain amount of time. Parameters timeout : The amount of seconds to show the bootloader for. expressSetup : Whether the Setup Assistant should start in Express Mode. disclaimer : Any license agreement or disclaimer that must be displayed during the Setup Assistant. bootView : The name of the Ren'Py screen to display as the GUI for the boot loader.","title":"Bootloader"},{"location":"System/05-bootloader/#bootloader","text":"The bootloader is responsible for displaying a boot screen while important components are loading. The bootloader is cusomizable with a certain timeout, depending on how fast you want the OS to \"load\".","title":"Bootloader"},{"location":"System/05-bootloader/#available-methods","text":"","title":"Available methods"},{"location":"System/05-bootloader/#asbootloaderboottimeout5-expresssetuptrue-disclaimernone-bootviewasbootloaderview","text":"Show the bootloader for a certain amount of time. Parameters timeout : The amount of seconds to show the bootloader for. expressSetup : Whether the Setup Assistant should start in Express Mode. disclaimer : Any license agreement or disclaimer that must be displayed during the Setup Assistant. bootView : The name of the Ren'Py screen to display as the GUI for the boot loader.","title":"$ ASBootloader.boot(timeout=5, expressSetup=True, disclaimer=None, bootView=\"ASBootloaderView\")"},{"location":"System/06-setup-assistant/","text":"Setup Assistant The Setup Assistant is a first-run tool designed to set any initial settings and/or configurations for AliceOS before starting the visual novel. It also lets the user create a username as well as read over and legel agreements or disclaimers the game creator has provided. Tip Starting with AliceOS Prospect Park, the Setup Assistant is automatically configured to use Express Mode, which skips a lot of the onerous steps in the original process. However, for a more thorough experience, Express Mode can be turned off. Automatic Setup In the Bootloader, the Setup Assistant will run if it doesn't detect that any setup was done. This check is done via persistent.AS_COMPLETED_SETUP . The boot loader's boot() method contains parameters to customize the Assistant's modes and any additional disclaimers, if necessary. Manual Setup If you want to call the Setup Assistant manually, you can use ASSetup.startSetup() to call the Assistant at any time. startSetup(express=True, disclaimer=None) Parameters express : Whether Express Mode is enabled. The default is set to True. disclaimer : A string containing any disclaimers or legal agreements. If set to None, the Setup Assistant will skip this step. Returns The Setup Assistant will return persistent.playername if it is deemed necessary for use. Adding steps to the Setup Assistant The Setup Assistant can be further customized by editing startSetup() in the core service file. The function calls the ASSetupAssistantView to display the step as a slide and collect any information if necessary. For example: renpy . call_screen ( ASSetupAssistantView , title = Create Your Username , instructions = Type in a username that you want to use while using AliceOS. This name will also appear as your character name if applicable. , useInputMethod = True ) ASSetupAssistantView(title=\"Setup Assistant\", instructions, useInputMethod=False, completed=False) Parameters title : The title of the step or slide. instructions : A brief description or set of instructions of what needs to be done on the step. useInputMethod : Whether to hide the 'Next' button and insert a text field instead. completed : Whether to change the 'Next' button text to 'Finish'. Returns If the screen is called using renpy.call_screen() , the following is returned: For steps that do not use the input method, 'didCompleteStep' is returned. For steps that use the input method, the input is returned as a string.","title":"Setup Assistant"},{"location":"System/06-setup-assistant/#setup-assistant","text":"The Setup Assistant is a first-run tool designed to set any initial settings and/or configurations for AliceOS before starting the visual novel. It also lets the user create a username as well as read over and legel agreements or disclaimers the game creator has provided. Tip Starting with AliceOS Prospect Park, the Setup Assistant is automatically configured to use Express Mode, which skips a lot of the onerous steps in the original process. However, for a more thorough experience, Express Mode can be turned off.","title":"Setup Assistant"},{"location":"System/06-setup-assistant/#automatic-setup","text":"In the Bootloader, the Setup Assistant will run if it doesn't detect that any setup was done. This check is done via persistent.AS_COMPLETED_SETUP . The boot loader's boot() method contains parameters to customize the Assistant's modes and any additional disclaimers, if necessary.","title":"Automatic Setup"},{"location":"System/06-setup-assistant/#manual-setup","text":"If you want to call the Setup Assistant manually, you can use ASSetup.startSetup() to call the Assistant at any time.","title":"Manual Setup"},{"location":"System/06-setup-assistant/#startsetupexpresstrue-disclaimernone","text":"Parameters express : Whether Express Mode is enabled. The default is set to True. disclaimer : A string containing any disclaimers or legal agreements. If set to None, the Setup Assistant will skip this step. Returns The Setup Assistant will return persistent.playername if it is deemed necessary for use.","title":"startSetup(express=True, disclaimer=None)"},{"location":"System/06-setup-assistant/#adding-steps-to-the-setup-assistant","text":"The Setup Assistant can be further customized by editing startSetup() in the core service file. The function calls the ASSetupAssistantView to display the step as a slide and collect any information if necessary. For example: renpy . call_screen ( ASSetupAssistantView , title = Create Your Username , instructions = Type in a username that you want to use while using AliceOS. This name will also appear as your character name if applicable. , useInputMethod = True )","title":"Adding steps to the Setup Assistant"},{"location":"System/06-setup-assistant/#assetupassistantviewtitlesetup-assistant-instructions-useinputmethodfalse-completedfalse","text":"Parameters title : The title of the step or slide. instructions : A brief description or set of instructions of what needs to be done on the step. useInputMethod : Whether to hide the 'Next' button and insert a text field instead. completed : Whether to change the 'Next' button text to 'Finish'. Returns If the screen is called using renpy.call_screen() , the following is returned: For steps that do not use the input method, 'didCompleteStep' is returned. For steps that use the input method, the input is returned as a string.","title":"ASSetupAssistantView(title=\"Setup Assistant\", instructions, useInputMethod=False, completed=False)"}]}